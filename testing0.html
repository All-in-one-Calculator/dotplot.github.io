<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Coordinatix 3D - Advanced</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
        font-family: 'Segoe UI', sans-serif;
      }
      body, html {
        width: 100%;
        height: 100%;
        margin: 0;
        overflow: auto;
      }
      #canvas-container {
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        z-index: 0;
        background-color: #000;
        overflow: hidden;
      }
      #equationContainer {
        position: fixed;
        top: 30px;
        left: 30px;
        width: 300px;
        height: calc(100vh - 60px);
        overflow-y: auto;
        padding: 20px;
        background: rgba(255, 255, 255, 0.2);
        border-radius: 16px;
        z-index: 10;
        box-shadow: 0 8px 20px rgba(0, 0, 0, 0.3);
        backdrop-filter: blur(10px);
        color: #fff;
      }
      #equationContainer h2 {
        font-size: 1.5em;
        margin-bottom: 20px;
      }
      .equation-row {
        display: flex;
        align-items: center;
        margin-bottom: 10px;
      }
      .equation-input {
        flex: 1;
        padding: 10px;
        border: 1px solid rgba(255, 255, 255, 0.4);
        border-radius: 6px 0 0 6px;
        background: rgba(255, 255, 255, 0.1);
        color: #ffffff;
        margin: 0;
      }
      .equation-input::placeholder {
        color: #eee;
      }
      button {
        padding: 10px 14px;
        margin: 5px 0;
        border: none;
        border-radius: 6px;
        cursor: pointer;
        background: #00aaff;
        color: white;
        transition: background 0.2s ease;
      }
      button:hover {
        background: #0077cc;
      }
      .remove-btn {
        padding: 10px 14px;
        background: rgba(255, 80, 80, 0.8);
        color: white;
        border: none;
        cursor: pointer;
        border-radius: 0 6px 6px 0;
        height: 100%;
        font-size: 1.2em;
      }
      .remove-btn:hover {
        background: rgba(255, 80, 80, 1);
      }
      #error {
        color: #ff8888;
        font-size: 0.9em;
        margin-top: 10px;
      }
      @media (max-width: 768px) {
        #equationContainer {
          width: 90%;
          left: 5%;
        }
      }
    </style>
  </head>
  <body>
    <div id="equationContainer">
      <h2>Coordinatix - Adv.</h2>
      <div id="error"></div>
    </div>
    <div id="canvas-container"></div>
    <script type="module">
      import * as THREE from './lib/three.module.js';
       import { OrbitControls } from './lib/OrbitControls.js';

      console.log('Initializing Three.js scene...');

      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(5, 5, 5);
      camera.lookAt(0, 0, 0);

      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      document.getElementById('canvas-container').appendChild(renderer.domElement);

      const controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;

      // Lighting
      const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
      directionalLight.position.set(5, 10, 7);
      directionalLight.castShadow = true;
      directionalLight.shadow.mapSize.width = 2048;
      directionalLight.shadow.mapSize.height = 2048;
      directionalLight.shadow.camera.near = 1;
      directionalLight.shadow.camera.far = 50;
      directionalLight.shadow.camera.left = -10;
      directionalLight.shadow.camera.right = 10;
      directionalLight.shadow.camera.top = 10;
      directionalLight.shadow.camera.bottom = -10;
      scene.add(directionalLight);

      const ambientLight = new THREE.AmbientLight(0x404040);
      scene.add(ambientLight);

      // Ground plane
      const groundGeo = new THREE.PlaneGeometry(100, 100);
      const groundMat = new THREE.ShadowMaterial({ opacity: 0.2 });
      const ground = new THREE.Mesh(groundGeo, groundMat);
      ground.rotation.x = -Math.PI / 2;
      ground.position.y = -0.01;
      ground.receiveShadow = true;
      scene.add(ground);

      const equationContainer = document.getElementById('equationContainer');
      const errorDiv = document.getElementById('error');
      const equations = [];
      const resolution = 100; // Reduced for performance
      const range = 10;

      // Vertex shader template
      const vertexShaderTemplate = `
        varying vec3 vNormal;
        varying vec3 vPosition;
        uniform float uRange;
        uniform float uResolution;

        float evaluate(float x, float y) {
          return {{EQUATION}};
        }

        void main() {
          vec2 pos = position.xy * uRange;
          float z = evaluate(pos.x, pos.y);
          if (isnan(z) || isinf(z)) z = 0.0; // Prevent NaN or infinity
          vec3 displacedPosition = vec3(pos.x, z, pos.y);

          vPosition = displacedPosition;
          vec3 dx = vec3(0.01, evaluate(pos.x + 0.01, pos.y) - z, 0.0);
          vec3 dy = vec3(0.0, evaluate(pos.x, pos.y + 0.01) - z, 0.01);
          vNormal = normalize(cross(dx, dy));

          gl_Position = projectionMatrix * modelViewMatrix * vec4(displacedPosition, 1.0);
        }
      `;

      const fragmentShader = `
        varying vec3 vNormal;
        uniform vec3 uColor;

        void main() {
          vec3 lightDir = normalize(vec3(5.0, 10.0, 7.0));
          float diff = max(dot(vNormal, lightDir), 0.2);
          vec3 color = uColor * diff;
          gl_FragColor = vec4(color, 1.0);
        }
      `;

      function sanitizeEquation(equation) {
        if (!equation || equation.trim() === '') {
          return '0.0'; // Fallback to flat plane
        }
        // Remove Math. prefix and convert to GLSL
        let glslEquation = equation
          .replace(/Math\./g, '')
          .replace(/\^/g, 'pow')
          .replace(/\bpow\(/g, 'pow(')
          .replace(/\bsqrt\(/g, 'sqrt(')
          .replace(/\babs\(/g, 'abs(')
          .replace(/\bsin\(/g, 'sin(')
          .replace(/\bcos\(/g, 'cos(')
          .replace(/\btan\(/g, 'tan(');
        // Validate allowed characters
        const allowedPattern = /^[0-9x*y+\-*/^()[\]\s\sin\cos\tan\sqrt\abs\pow]+$/;
        if (!allowedPattern.test(glslEquation)) {
          throw new Error('Invalid characters in equation. Use x, y, numbers, +, -, *, /, sin, cos, tan, sqrt, abs, pow.');
        }
        return glslEquation;
      }

      function createShaderMaterial(color, equation) {
        let glslEquation;
        try {
          glslEquation = sanitizeEquation(equation);
        } catch (e) {
          throw new Error(e.message);
        }
        const vertexShader = vertexShaderTemplate.replace('{{EQUATION}}', glslEquation);
        const material = new THREE.ShaderMaterial({
          vertexShader,
          fragmentShader,
          uniforms: {
            uRange: { value: range },
            uResolution: { value: resolution },
            uColor: { value: new THREE.Color(color) }
          },
          side: THREE.DoubleSide,
          wireframe: false
        });
        // Verify shader compilation
        const gl = renderer.getContext();
        const program = material.program;
        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
          const info = gl.getProgramInfoLog(program);
          throw new Error(`Shader compilation failed: ${info}`);
        }
        return material;
      }

      function createEquationRow(index, defaultValue = '') {
        console.log(`Creating equation row ${index}`);
        const row = document.createElement('div');
        row.className = 'equation-row';

        const input = document.createElement('input');
        input.type = 'text';
        input.placeholder = 'z = f(x, y) (e.g., sin(x * y))';
        input.className = 'equation-input';
        input.value = defaultValue;

        let debounceTimeout;
        input.addEventListener('input', () => {
          clearTimeout(debounceTimeout);
          debounceTimeout = setTimeout(() => {
            console.log(`Input changed for row ${index}: ${input.value}`);
            const existing = equations[index];
            if (existing && existing.mesh) {
              scene.remove(existing.mesh);
              existing.mesh.geometry.dispose();
              existing.mesh.material.dispose();
            }
            if (input.value.trim() !== '') {
              try {
                addEquation(input, index);
                errorDiv.textContent = '';
              } catch (e) {
                errorDiv.textContent = `Error: ${e.message}`;
                console.error('Equation error:', e);
                equations[index] = null;
              }
            } else {
              equations[index] = null;
            }
            ensureEmptyRow();
          }, 300);
        });

        const remove = document.createElement('button');
        remove.className = 'remove-btn';
        remove.textContent = 'âœ•';
        remove.addEventListener('click', () => {
          console.log(`Removing equation row ${index}`);
          const existing = equations[index];
          if (existing && existing.mesh) {
            scene.remove(existing.mesh);
            existing.mesh.geometry.dispose();
            existing.mesh.material.dispose();
          }
          equations[index] = null;
          equationContainer.removeChild(row);
          ensureEmptyRow();
        });

        row.appendChild(input);
        row.appendChild(remove);
        equationContainer.appendChild(row);
      }

      function addEquation(input, index) {
        console.log(`Adding equation for index ${index}: ${input.value}`);
        const geometry = new THREE.PlaneGeometry(range * 2, range * 2, resolution, resolution);
        geometry.rotateX(-Math.PI / 2);
        const color = new THREE.Color().setHSL(index * 0.3 % 1, 0.6, 0.5);
        const material = createShaderMaterial(color, input.value);
        const mesh = new THREE.Mesh(geometry, material);
        mesh.castShadow = true;
        mesh.receiveShadow = true;
        scene.add(mesh);
        equations[index] = { input, mesh };
      }

      function ensureEmptyRow() {
        const allInputs = equationContainer.querySelectorAll('input');
        const hasEmpty = Array.from(allInputs).some(input => input.value.trim() === '');
        if (!hasEmpty && allInputs.length > 0) {
          createEquationRow(equations.length);
        }
      }

      // Initialize with a default equation
      try {
        console.log('Creating initial equation row');
        createEquationRow(0, 'sin(x * y)');
        addEquation({ value: 'sin(x * y)' }, 0);
      } catch (e) {
        console.error('Error initializing default equation:', e);
        errorDiv.textContent = `Initialization error: ${e.message}`;
      }

      function animate() {
        requestAnimationFrame(animate);
        controls.update();
        renderer.render(scene, camera);
      }

      try {
        console.log('Starting animation loop');
        animate();
      } catch (e) {
        console.error('Animation error:', e);
        errorDiv.textContent = `Animation error: ${e.message}`;
      }

      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });

      // Log WebGL context info
      const gl = renderer.getContext();
      console.log('WebGL Version:', gl.getParameter(gl.VERSION));
      console.log('Shader Precision:', gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_FLOAT).precision);
    </script>
  </body>
</html>