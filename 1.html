<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" />
  <title>Coordinatix 3D - Shader Based with Shadows</title>
  <style>
    /* CSS remains unchanged */
    * { margin: 0; padding: 0; box-sizing: border-box; font-family: 'Segoe UI', sans-serif; }
    body, html { width: 100%; height: 100%; overflow: auto; }
    #canvas-container { position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; z-index: 0; background-color: #000; overflow: hidden; }
    #sidebar { position: fixed; top: 30px; left: 30px; width: 300px; height: calc(100vh - 60px); overflow-y: auto; padding: 20px; background: rgba(255, 255, 255, 0.2); border-radius: 16px; z-index: 10; box-shadow: 0 8px 20px rgba(0, 0, 0, 0.3); backdrop-filter: blur(10px); color: #fff; }
    #sidebar h2 { font-size: 1.5em; margin-bottom: 20px; }
    .equation-input { width: 100%; padding: 10px; margin-bottom: 10px; border: 1px solid rgba(255,255,255,0.4); border-radius: 6px; background: rgba(255, 255, 255, 0.3); color: #fff; }
    .equation-row { display: flex; align-items: center; margin-bottom: 10px; }
    .equation-input { flex: 1; padding: 10px; border: 1px solid rgba(255, 255, 255, 0.135); border-radius: 6px 0 0 6px; background: rgba(255, 255, 255, 0.011); color: #ffffff; margin: 0; }
    button { padding: 10px 14px; margin: 5px 0; border: none; border-radius: 6px; cursor: pointer; background: #00aaff; color: white; transition: background 0.2s ease; }
    button:hover { background: #0077cc00; }
    .remove-btn { padding: 10px 14px; background: rgba(255, 80, 80, 0); color: white; border: none; cursor: pointer; border-radius: 0 6px 6px 0; height: 100%; font-size: 1.2em; }
    .remove-btn:hover { transform: scale(1.2); }
    #error { color: #ff8888; font-size: 0.9em; margin-top: 10px; }
    @media (max-width: 768px) { #sidebar { width: 90%; left: 5%; } }
  </style>
</head>
<body>
  <div id="sidebar">
    <h2>Coordinatix</h2>
    <div id="equations"></div>
    <div id="error"></div>
  </div>
  <div id="canvas-container"></div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.134/examples/js/controls/OrbitControls.js"></script>

  <script>
    let scene, camera, renderer, controls;
    const equations = [];
    const meshes = [];
    const range = 10;
    const resolution = 1000; // Reduced for performance with shadows

    function init() {
      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(5, 5, 10);

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.shadowMap.enabled = true; // Enable shadow mapping
      renderer.shadowMap.type = THREE.PCFSoftShadowMap; // Soft shadows for better realism
      document.getElementById('canvas-container').appendChild(renderer.domElement);

      controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;

      // Add a ground plane to receive shadows
      const groundGeometry = new THREE.PlaneGeometry(20, 20);
      const groundMaterial = new THREE.MeshStandardMaterial({ color: 0x333333, side: THREE.DoubleSide });
      groundMaterial.receiveShadow = true; // Ground receives shadows
      const ground = new THREE.Mesh(groundGeometry, groundMaterial);
      ground.rotation.x = Math.PI / 2;
      ground.visible = false;
      ground.position.y = -5; // Place below the graph
      scene.add(ground);

      scene.add(new THREE.AxesHelper(5));
      scene.add(new THREE.GridHelper(20, 20));

      // Ambient light for soft base illumination
      scene.add(new THREE.AmbientLight(0xffffff, 0.3));

      // Directional light for shadows
      const light = new THREE.DirectionalLight(0xffffff, 0.7);
      light.position.set(10, 10, 10);
      light.castShadow = true; // Enable shadow casting
      light.shadow.mapSize.width = 1024; // Higher resolution shadow map
      light.shadow.mapSize.height = 1024;
      light.shadow.camera.near = 0.5;
      light.shadow.camera.far = 50;
      light.shadow.camera.left = -15;
      light.shadow.camera.right = 15;
      light.shadow.camera.top = 15;
      light.shadow.camera.bottom = -15;
      scene.add(light);

      // Optional: Add helper to visualize light's shadow camera
      // scene.add(new THREE.CameraHelper(light.shadow.camera));

      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });

      animate();
    }

    function createShaderMaterial(equationGLSL, color) {
      return new THREE.ShaderMaterial({
        vertexShader: `
          uniform float range;
          varying vec3 vColor;
          varying vec3 vPosition;
          varying vec3 vNormal;

          void main() {
            float x = position.x;
            float y = position.y;
            float z = ${equationGLSL};

            vPosition = vec3(x, y, z);

            // Calculate approximate normals using finite differences
            float delta = 0.01;
            float z1 = ${equationGLSL.replace(/x/g, '(x + delta)')};
            float z2 = ${equationGLSL.replace(/y/g, '(y + delta)')};
            vec3 tangentX = vec3(delta, 0.0, z1 - z);
            vec3 tangentY = vec3(0.0, delta, z2 - z);
            vNormal = normalize(cross(tangentX, tangentY));

            vColor = vec3(${color.r.toFixed(2)}, ${color.g.toFixed(2)}, ${color.b.toFixed(2)});
            gl_Position = projectionMatrix * modelViewMatrix * vec4(vPosition, 1.0);
          }
        `,
        fragmentShader: `
          varying vec3 vColor;
          varying vec3 vNormal;
          varying vec3 vPosition;

          uniform vec3 lightPosition;

          void main() {
            vec3 lightDir = normalize(lightPosition - vPosition);
            float diff = max(dot(normalize(vNormal), lightDir), 0.0);

            // Enhance diffuse lighting with sharper falloff
            diff = pow(diff, 1.5); // Slightly sharper than before

            // Add specular highlight for more realism
            vec3 viewDir = normalize(-vPosition); // Assuming camera at origin in view space
            vec3 halfwayDir = normalize(lightDir + viewDir);
            float spec = pow(max(dot(vNormal, halfwayDir), 0.0), 32.0); // Shininess factor

            float ambient = 0.2; // Increased ambient for visibility
            float specular = 0.3; // Specular intensity
            vec3 shadedColor = vColor * (ambient + (1.0 - ambient) * diff) + vec3(1.0) * spec * specular;

            gl_FragColor = vec4(shadedColor, 1.0);
          }
        `,
        uniforms: {
          range: { value: range },
          lightPosition: { value: new THREE.Vector3(10, 10, 10) }
        },
        side: THREE.DoubleSide,
        transparent: false, // Disable transparency for better shadow rendering
        shadowSide: THREE.DoubleSide, // Enable shadows on both sides
      });
    }

    function convertToGLSL(expr) {
      return expr
        .replace(/Math\./g, '')
        .replace(/sin/g, 'sin')
        .replace(/cos/g, 'cos')
        .replace(/tan/g, 'tan')
        .replace(/exp/g, 'exp')
        .replace(/log/g, 'log')
        .replace(/sqrt/g, 'sqrt')
        .replace(/abs/g, 'abs');
    }

    function updateEquation(index, text) {
      equations[index].text = text.trim();
      document.getElementById('error').innerText = '';

      if (meshes[index]) {
        scene.remove(meshes[index]);
        meshes[index].geometry.dispose();
        meshes[index].material.dispose();
        meshes[index] = null;
      }

      if (!text.trim()) return;

      try {
        const equationGLSL = convertToGLSL(text.trim());
        const geometry = new THREE.PlaneGeometry(range * 2, range * 2, resolution, resolution);
        const color = new THREE.Color(equations[index].color);
        const material = createShaderMaterial(equationGLSL, color);

        const mesh = new THREE.Mesh(geometry, material);
        mesh.castShadow = true; // Mesh casts shadows
        mesh.receiveShadow = true; // Mesh receives shadows
        meshes[index] = mesh;
        scene.add(mesh);
      } catch (e) {
        document.getElementById('error').innerText = `Error in equation ${index + 1}: ${e.message}`;
      }
    }

    function addEquation(equationText = '') {
      const container = document.getElementById('equations');
      const index = equations.length;
      equations.push({ text: equationText, color: getRandomColor() });

      const row = document.createElement('div');
      row.className = 'equation-row';

      const input = document.createElement('input');
      input.type = 'text';
      input.className = 'equation-input';
      input.placeholder = 'Enter equation (e.g., sin(x) + cos(y))';
      input.value = equationText;

      const removeBtn = document.createElement('button');
      removeBtn.className = 'remove-btn';

      const iconImg = document.createElement('img');
      iconImg.src = 'images/svg.svg'; // âœ… Put correct path here
      iconImg.alt = 'Delete';
      iconImg.width = 16;
      iconImg.height = 16;
      iconImg.style.pointerEvents = 'none';

removeBtn.appendChild(iconImg);


      removeBtn.onclick = () => {
        equations[index] = null;
        if (meshes[index]) {
          scene.remove(meshes[index]);
          meshes[index].geometry.dispose();
          meshes[index].material.dispose();
          meshes[index] = null;
        }
        container.removeChild(row);
        const remainingRows = document.querySelectorAll('.equation-row').length;
        while (remainingRows < 2) {
          addEquation('');
          break;
        }
      };

      input.oninput = () => {
        updateEquation(index, input.value);
        const inputs = document.querySelectorAll('.equation-input');
        const isLast = input === inputs[inputs.length - 1];
        if (isLast && input.value.trim() !== '') {
          addEquation('');
        }
      };

      row.appendChild(input);
      row.appendChild(removeBtn);
      container.appendChild(row);

      updateEquation(index, equationText);
    }

    function getRandomColor() {
      return `#${Math.floor(Math.random() * 16777215).toString(16).padStart(6, '0')}`;
    }

    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    }

    init();
    addEquation('sin(x) + cos(y)');
    addEquation('');
  </script>
</body>
</html>