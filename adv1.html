<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" />
  <title>Coordinatix 3D - Shader Based</title>
  <style>
    /* --- CSS unchanged from your original code --- */
    * { margin: 0; padding: 0; box-sizing: border-box; font-family: 'Segoe UI', sans-serif; }
    body, html { width: 100%; height: 100%; overflow: auto; }
    #canvas-container { position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; z-index: 0; background-color: #000; overflow: hidden; }
    #sidebar { position: fixed; top: 30px; left: 30px; width: 300px; height: calc(100vh - 60px); overflow-y: auto; padding: 20px; background: rgba(255, 255, 255, 0.2); border-radius: 16px; z-index: 10; box-shadow: 0 8px 20px rgba(0, 0, 0, 0.3); backdrop-filter: blur(10px); color: #fff; }
    #sidebar h2 { font-size: 1.5em; margin-bottom: 20px; }
    .equation-input { width: 100%; padding: 10px; margin-bottom: 10px; border: 1px solid rgba(255,255,255,0.4); border-radius: 6px; background: rgba(255, 255, 255, 0.3); color: #fff; }
    .equation-row { display: flex; align-items: center; margin-bottom: 10px; }
    .equation-input { flex: 1; padding: 10px; border: 1px solid rgba(255, 255, 255, 0.135); border-radius: 6px 0 0 6px; background: rgba(255, 255, 255, 0.011); color: #ffffff; margin: 0; }
    button { padding: 10px 14px; margin: 5px 0; border: none; border-radius: 6px; cursor: pointer; background: #00aaff; color: white; transition: background 0.2s ease; }
    button:hover { background: #0077cc00; }
    .remove-btn { padding: 10px 14px; background: rgba(255, 80, 80, 0); color: white; border: none; cursor: pointer; border-radius: 0 6px 6px 0; height: 100%; font-size: 1.2em; }
    .remove-btn:hover { transform: scale(1.2); }
    #error { color: #ff8888; font-size: 0.9em; margin-top: 10px; }
    @media (max-width: 768px) { #sidebar { width: 90%; left: 5%; } }
  </style>
</head>
<body>
  <div id="sidebar">
    <h2>Coordinatix</h2>
    <div id="equations"></div>
    <div id="error"></div>
  </div>
  <div id="canvas-container"></div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.134/examples/js/controls/OrbitControls.js"></script>

  <script>
    let scene, camera, renderer, controls;
    const equations = [];
    const meshes = [];
    const range = 10;
    const resolution = 2000;

    function init() {
      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(5, 5, 10);

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.getElementById('canvas-container').appendChild(renderer.domElement);

      controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;

      scene.add(new THREE.AxesHelper(5));
      scene.add(new THREE.GridHelper(20, 20));
      scene.add(new THREE.AmbientLight(0xffffff, 0.4));
      const light = new THREE.DirectionalLight(0xffffff, 0.8);
      light.position.set(10, 10, 10);
      scene.add(light);

      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });

      animate();
    }

    function createShaderMaterial(equationGLSL, color) {
  return new THREE.ShaderMaterial({
    vertexShader: `
      uniform float range;
      varying vec3 vColor;
      varying vec3 vPosition;
      varying vec3 vNormal;

      void main() {
        float x = position.x;
        float y = position.y;
        float z = ${equationGLSL};

        vPosition = vec3(x, y, z);

        // Simple upward normal for now
        vNormal = normalize(vec3(0.0, 0.0, 1.0));

        vColor = vec3(${color.r.toFixed(2)}, ${color.g.toFixed(2)}, ${color.b.toFixed(2)});
        gl_Position = projectionMatrix * modelViewMatrix * vec4(vPosition, 1.0);
      }
    `,
    fragmentShader: `
      varying vec3 vColor;
      varying vec3 vNormal;
      varying vec3 vPosition;

      uniform vec3 lightPosition;

      void main() {
        vec3 lightDir = normalize(lightPosition - vPosition);
        float diff = max(dot(normalize(vNormal), lightDir), 0.0);

        // Sharpen the lighting and deepen shadows
        diff = pow(diff, 2.0); // Higher = sharper & darker shadows (try 2.5 or 3.0 if needed)

        float ambient = 0.08; // Minimum brightness so shadows aren't fully black
        vec3 shadedColor = vColor * (ambient + (1.0 - ambient) * diff);

        gl_FragColor = vec4(shadedColor, 1.0);
      }
    `,
    uniforms: {
      range: { value: range },
      lightPosition: { value: new THREE.Vector3(10, 10, 10) }
    },
    side: THREE.DoubleSide,
    wireframe: false
  });
}



    function convertToGLSL(expr) {
      return expr
        .replace(/Math\./g, '')
        .replace(/sin/g, 'sin')
        .replace(/cos/g, 'cos')
        .replace(/tan/g, 'tan')
        .replace(/exp/g, 'exp')
        .replace(/log/g, 'log')
        .replace(/sqrt/g, 'sqrt')
        .replace(/abs/g, 'abs');
    }

    function updateEquation(index, text) {
      equations[index].text = text.trim();
      document.getElementById('error').innerText = '';

      if (meshes[index]) {
        scene.remove(meshes[index]);
        meshes[index].geometry.dispose();
        meshes[index].material.dispose();
        meshes[index] = null;
      }

      if (!text.trim()) return;

      try {
        const equationGLSL = convertToGLSL(text.trim());
        const geometry = new THREE.PlaneGeometry(range * 2, range * 2, resolution, resolution);
        const color = new THREE.Color(equations[index].color);
        const material = createShaderMaterial(equationGLSL, color);

        const mesh = new THREE.Mesh(geometry, material);
        meshes[index] = mesh;
        scene.add(mesh);
      } catch (e) {
        document.getElementById('error').innerText = `Error in equation ${index + 1}: ${e.message}`;
      }
    }

    function addEquation(equationText = '') {
      const container = document.getElementById('equations');
      const index = equations.length;
      equations.push({ text: equationText, color: getRandomColor() });

      const row = document.createElement('div');
      row.className = 'equation-row';

      const input = document.createElement('input');
      input.type = 'text';
      input.className = 'equation-input';
      input.placeholder = 'Enter equation (e.g., sin(x) + cos(y))';
      input.value = equationText;

      const removeBtn = document.createElement('button');
      removeBtn.className = 'remove-btn';
      removeBtn.innerHTML = '<i class="fas fa-times"></i>';

      removeBtn.onclick = () => {
        equations[index] = null;
        if (meshes[index]) {
          scene.remove(meshes[index]);
          meshes[index].geometry.dispose();
          meshes[index].material.dispose();
          meshes[index] = null;
        }
        container.removeChild(row);
        const remainingRows = document.querySelectorAll('.equation-row').length;
        while (remainingRows < 2) {
          addEquation('');
          break;
        }
      };

      input.oninput = () => {
        updateEquation(index, input.value);
        const inputs = document.querySelectorAll('.equation-input');
        const isLast = input === inputs[inputs.length - 1];
        if (isLast && input.value.trim() !== '') {
          addEquation('');
        }
      };

      row.appendChild(input);
      row.appendChild(removeBtn);
      container.appendChild(row);

      updateEquation(index, equationText);
    }

    function getRandomColor() {
      return `#${Math.floor(Math.random() * 16777215).toString(16).padStart(6, '0')}`;
    }

    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    }

    init();
    addEquation('sin(x) + cos(y)');
    addEquation('');
  </script>
</body>
</html>